import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import matplotlib.colors as colors
import numpy as np
from utils import make_scan_vectors, make_scan_grids, moving_avg, to_real_units, clear_artists
from utils import make_gate_vectors, to_real_units_double_loops
from typing import Dict, List, Optional, Sequence, Any, Union, Tuple

class gatePlot(object):
    """Plot displaying voltage across 4 prob leads with a gate, updated live during a scan.
    """
    def __init__(self, gated_params: Dict[str, Any], ureg: Any) -> None:
        """
        Args:
            tdc_params: Touchdown parameters as defined in measurement configuration file.
            ureg: pint UnitRegistry, manages units.
        """
        self.gated_params = gated_params
        self.constants = gated_params['constants']
        self.channels = gated_params['channels']
        self.R_lead = self.channels['IV']['r_lead']
        self.name = gated_params['name']
        self.direction = gated_params['direction']
        self.curr_amp = self.channels['IV']['curr_amp']
        self.amplitude = self.channels['IV']['lockin']['amplitude']
        self.frequency = self.channels['IV']['lockin']['frequency']
        self.attenuator = self.channels['IV']['attenuator']
        self.ureg = ureg
        self.Q_ = ureg.Quantity
        self.fig, self.ax = plt.subplots(1,1)
        self.fig.patch.set_alpha(1)
        self.init_empty()

    def init_empty(self):
        """Initialize the plot with no data.
        """
        dV = self.Q_(self.gated_params['dV']).to('V').magnitude
        if self.direction == 'forwards':
            startV, endV = sorted([self.Q_(lim).to('V').magnitude for lim in self.gated_params['range']])
            npnts = int((endV - startV) / dV) + 1
        elif self.direction == 'backwards':
            endV, startV = sorted([self.Q_(lim).to('V').magnitude for lim in self.gated_params['range']])
            npnts = int((startV - endV) / dV) + 1
        else:
            startV, endV = sorted([self.Q_(lim).to('V').magnitude for lim in self.gated_params['range']])
            npnts = int((endV - startV) / dV) + 1

        self.gate = np.linspace(startV, endV, npnts)
        self.ax.set_xlim(min(self.gate), max(self.gate))
        self.ax.grid()
        self.ax.set_xlabel('gate voltage (V)', fontsize = 10)
        self.ax.set_ylabel('current(A)', fontsize = 10 )
        self.ax.ticklabel_format(axis = "y", style = "sci", scilimits = (0,0))
        self.ax.set_title('curr_amp ={}, lockin A={}, f={}, {}'.format(self.curr_amp, 
            self.amplitude, self.frequency, self.name))
        self.fig.canvas.draw()
        #self.fig.show()

    def update(self, data_set: Any) -> None:
        """Update plot with data from data_set.
        Args:
            data_set: DataSet generated by Loop in Microscope.td_cap().
        """
        self.location = data_set.location
        self.fig.suptitle(self.location, x=0.5, y=1)
        self.prefactors = data_set.metadata['loop']['metadata']['prefactors']
        all_data = to_real_units(data_set)
        npnts = len(all_data[:,0,0][np.isfinite(all_data[:,0,0])])
        self.gdata = self.gate[:npnts]
        data = all_data[:,0,0][np.isfinite(all_data[:,0,0])]
        if len(self.gdata) == len(data):
            clear_artists(self.ax)
            self.ax.plot(self.gdata,data, 'b')
            self.ax.plot(self.gdata[-1], data[-1], 'r.')
            #self.ax.yaxis.set_major_formatter(ticker.FormatStrFormatter('%.3f'))
            self.Fbdata = data
        self.fig.canvas.draw()

    def save(self, fname=None):
        """Save plot to png file.
        Args:
            fname: File to which to save the plot.
                If fname is None, saves to data location as {tdc_params['fname']}.png
        """
        if fname is None:
            fname = self.location +'/ gated_IV.png'
        plt.savefig(fname)


    # def _clear_artists(self, ax):
    #     """Clears lines and collections of lines from given matplotlib axis.

    #     Args:
    #         ax: axis to clear.
    #     """
    #     for artist in ax.lines + ax.collections:
    #         artist.remove()
class DoubleGatedPlot(object):
    """Plot displaying sample leads voltage difference as a function of top and bottom gates,
     updated live during a scan.
    """

    def __init__(self,  gated_params: Dict[str, Any], ureg: Any, **kwargs) -> None:

        """
        Args:
            tdc_params: Touchdown parameters as defined in measurement configuration file.
            ureg: pint UnitRegistry, manages units.
        """
        self.gated_params = gated_params
        self.constants = gated_params['constants']
        self.channels = gated_params['channels']
        self.R_lead = self.channels['IV']['r_lead']
        self.amplitude = self.channels['IV']['lockin']['amplitude']
        self.frequency = self.channels['IV']['lockin']['frequency']
        self.ureg = ureg
        self.Q_ = ureg.Quantity
        self.fast_ax = gated_params['fast_ax']
        self.slow_ax = 'Y' if self.fast_ax == 'X' else 'X'
        self.line_colors = ['#d80202' ,'#545454' ,'#777777' ,'#a8a8a8', '#d1d1d1']
        MAXN_COLS = 3
        N = len(self.channels.keys())
        cols = N if N < MAXN_COLS else MAXN_COLS
        plot_rows = int(np.ceil(N / cols))
        rows = 2 * plot_rows
        #self.fig, self.ax = plt.subplots(rows, cols, figsize=(10,4.5 * plot_rows), tight_layout=True,
                                         #gridspec_kw={"height_ratios":[0.075, 1, 0.5]*plot_rows})
        self.fig, self.ax = plt.subplots(rows, cols, figsize=(10,4.5 * plot_rows), tight_layout=True,
                                         gridspec_kw={"height_ratios":[0.075, 1]*plot_rows})
        self.fig.patch.set_alpha(1)
        #self.plots = {'colorbars': {}, 'images': {}, 'lines': {}}
        self.plots = {'colorbars': {}, 'images': {}}
        for i, ch in enumerate(self.channels.keys()):
            self.plots['colorbars'].update({ch: {'cax': self.ax[0][i]}})
            self.plots['images'].update({ch: {'ax' :self.ax[1][i]}})
            #self.plots['lines'].update({ch: self.ax[2][i]})
        for ch, ax in self.plots['images'].items():
            ax['ax'].set_aspect('equal')
            ax['ax'].set_xlabel(gated_params['Xkei'] + ' V')
            ax['ax'].set_ylabel(gated_params['Ykei'] + ' V')
        #for ch, ax in self.plots['lines'].items():
            #ax.set_aspect('auto')
            #ax.set_xlabel('{} gate voltage [V]'.format(self.fast_ax))
        self.init_empty()
     
    def init_empty(self):
        """Initialize the plot with all images empty. They will be filled during the scan.
        """
        self.gate_vectors = make_gate_vectors(self.gated_params, self.ureg)
        self.X, self.Y = np.meshgrid(self.gate_vectors['X'], self.gate_vectors['Y'])
        empty = np.full_like(self.X, np.nan, dtype=np.double)
        for ch in self.channels:
            im = self.plots['images'][ch]['ax'].pcolormesh(self.X, self.Y, empty)
            self.plots['images'][ch].update({'quad': im})
            cbar = plt.colorbar(im, cax=self.plots['colorbars'][ch]['cax'], orientation='horizontal')
            self.plots['colorbars'][ch]['cax'].set_label(r'{}'.format(self.channels[ch]['unit_latex']))
            self.plots['colorbars'][ch].update({'cbar': cbar})
        for ax, ch in zip(self.ax[0], self.channels.keys()):
            ax.set_title(self.channels[ch]['label'])
        self.fig.canvas.draw()
            
    def update(self, data_set: Any,  num_lines: Optional[int]=5,
               offline: Optional[bool]=False) -> None:
        """Update the plot with updated DataSet. Called after each line of the scan.

        Args:
            DataSet: active data set, with a new line of data added with each loop iteration.
            loop_counter: utils.Counter instance, lets us know where we are in the scan.
            num_lines: Number of previous linecuts to plot, including the line just scanned.
                Currently can only handle num_lines <= 5.
            offline: False if this is being called during a scan.

        ..TODO:: Add support for arbitrary num_lines?
        """
        self.location = data_set.location
        self.fig.suptitle(self.location, x=0.5, y=1)
        #print(data_set)
        self.prefactors = data_set.metadata['loop']['metadata']['prefactors']
        data = to_real_units_double_loops(data_set)
        #print(data)
        #print(data.shape)
        meta = data_set.metadata['loop']['metadata']
        #print(meta)
        #slow_ax = 'B' if meta['DAQ_AO'] == 'T' else 'T'
        slow_ax = 'Y' if meta['fast_ax'] == 'X' else 'X'
        #line = loop_counter.count if not offline else meta['scan_size'][slow_ax] - 1
        for idx, ch in enumerate(self.channels):
            data_ch = data[:,:,idx,0]
            #print(data_ch.shape)
            #data_ch = data[:,:,idx]
            if self.fast_ax == 'Y':
                data_ch = data_ch.T
            clear_artists(self.plots['images'][ch]['ax'])
            #print(np.ma.masked_invalid(data_ch))
            #clear_artists(self.plots['lines'][ch])
            norm = colors.Normalize().autoscale(np.ma.masked_invalid(data_ch))
            self.plots['images'][ch]['quad'] = self.plots['images'][ch]['ax'].pcolormesh(
                self.X, self.Y, np.ma.masked_invalid(data_ch), norm=norm, shading= 'auto')
            self.plots['colorbars'][ch]['cbar'] = self.fig.colorbar(self.plots['images'][ch]['quad'],
                                                                    cax=self.plots['colorbars'][ch]['cax'],
                                                                    orientation='horizontal')
            self.plots['colorbars'][ch]['cbar'].locator = ticker.MaxNLocator(nbins=3)
            self.plots['colorbars'][ch]['cbar'].update_ticks()
            self.plots['colorbars'][ch]['cbar'].set_label(r'{}'.format(self.channels[ch]['unit_latex']))
            self.plots['colorbars'][ch]['cbar'].update_normal(self.plots['images'][ch]['quad'])
            self.plots['images'][ch]['ax'].relim()
            #self.plots['lines'][ch].relim()
            self.plots['colorbars'][ch]['cax'].minorticks_on()
            #: Update linecuts
            xdata = self.gate_vectors[self.fast_ax]
            # something weird happens where there is less than 10 data points

            #if line < num_lines:
                #for l in range(line+1):
                    #ydata = data_ch[:,l] if self.fast_ax == 'T' else data_ch[l,:]
                    #print(ydata)
                    #self.plots['lines'][ch].plot(xdata, ydata, lw=2, color=self.line_colors[line-l])
            #else:
                #for l in range(num_lines):
                    #ydata = data_ch[:,line-num_lines+l+1] if self.fast_ax == 'T' else data_ch[line-num_lines+l+1,:]
                    #print(ydata)
                    #self.plots['lines'][ch].plot(xdata, ydata, lw=2, color=self.line_colors[num_lines-l-1])
        self.fig.canvas.draw()
        #self.fig.show()
        
    def save(self, fname=None):
        """Save plot to png file.

        Args:
            fname: File to which to save the plot.
                If fname is None, saves to data location as {scan_params['fname']}.png
        """
        if fname is None:
            fname = self.location + '/' + self.gated_params['fname'] +'.png'
        plt.savefig(fname)
            

class MSvTPlot(object):
    """Plot displaying MAG, SUSCX, and TEMP as a function of temperature, updated live during a scan.
    """
    def __init__(self, temps_params: Dict[str, Any], ureg: Any) -> None:
        """
        Args:
            tdc_params: Touchdown parameters as defined in measurement configuration file.
            ureg: pint UnitRegistry, manages units.
        """
        self.temps_params = temps_params
        self.constants = temps_params['constants']
        self.channels = temps_params['channels']
        self.ureg = ureg
        self.Q_ = ureg.Quantity
        self.fig, self.ax = plt.subplots(1,len(self.channels),figsize=(5*len(self.channels),5), tight_layout=True)
        self.fig.patch.set_alpha(1)
        self.init_empty()

    def init_empty(self):
        """Initialize the plot with no data.
        """
        dT = self.Q_(self.temps_params['dT']).to('K').magnitude
        startT, endT = [self.Q_(lim).to('K').magnitude for lim in self.temps_params['range']]
        npnts = int((endT - startT) / dT) + 1
        self.Temp = np.linspace(startT, endT, npnts)
        for i, ch in enumerate(self.channels):
            self.ax[i].set_xlim(min(self.Temp), max(self.Temp))
            self.ax[i].grid()
            self.ax[i].set_xlabel('Temperature (K)')
            self.ax[i].set_ylabel(r'{} [{}]'.format(self.channels[ch]['label'], self.channels[ch]['unit_latex']))
            self.ax[i].set_title(self.channels[ch]['label'])
        self.fig.canvas.draw()
        # self.fig.tight_layout()
        # self.fig.show()


    def update(self, data_set: Any) -> None:
        """Update plot with data from data_set.
        Args:
            data_set: DataSet generated by Loop in Microscope.temp_series().
        """
        self.location = data_set.location
        self.fig.suptitle(self.location, x=0.5, y=1)
        self.prefactors = data_set.metadata['loop']['metadata']['prefactors']
        all_data = to_real_units(data_set)
        npnts = len(all_data[:,0,0][np.isfinite(all_data[:,0,0])])
        self.Tdata = self.Temp[:npnts]
        for i, ch in enumerate(self.channels):
            data = all_data[:,i,0][np.isfinite(all_data[:,i,0])]   
            if len(self.Tdata) == len(data):
                clear_artists(self.ax[i])
                self.ax[i].plot(self.Tdata, data, 'b.')
                self.ax[i].plot(self.Tdata[-1], data[-1], 'r.')
            if ch == 'MAG':
                self.mdata = data
            elif ch == 'SUSCX':
                self.sxdata = data
            elif ch == 'SUSCY':
                self.sydata = data
            elif ch == 'Sample_T':
                self.tdata = data
        self.fig.canvas.draw()


    def save(self, fname=None):
        """Save plot to png file.
        Args:
            fname: File to which to save the plot.
                If fname is None, saves to data location as {temps_params['fname']}.png
        """

        if fname is None:
            fname = self.location + '/' + self.temps_params['fname'] +'.png'
        plt.savefig(fname)
